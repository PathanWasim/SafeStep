import cv2
import time
import numpy as np
import pyttsx3
import tkinter as tk
from tkinter import ttk, simpledialog, messagebox
from threading import Thread
from queue import Queue
from ultralytics import YOLO
from PIL import Image, ImageTk
import json
import datetime

class ObjectDetectionSystem:
    def __init__(self):
        # Initialize core components
        self.model = YOLO("yolo11m.pt")
        self.cap = cv2.VideoCapture(0)
        self.queue = Queue()
        self.announcement_enabled = [True]
        self.detection_log = []
        
        # Configuration settings
        self.config = {
            "confidence": 0.5,
            "detection_mode": "all",
            "alert_distance": 2.0,
            "voice_speed": 150,
            "voice_volume": 1.0,
            "alert_cooldown": 2.0
        }
        
        # Load saved settings if they exist
        self.load_settings()
        
        # Initialize GUI
        self.setup_gui()
        
        # Start speech thread
        self.start_speech_thread()

    def setup_gui(self):
        # Main window setup
        self.root = tk.Tk()
        self.root.title("Indoor Navigation System")
        self.root.geometry("1200x800")
        self.root.configure(bg="#1E1E1E")
        
        # Configure styles
        self.setup_styles()
        
        # Create main containers
        self.create_layout()
        
        # Start frame updates
        self.update_frame()

    def setup_styles(self):
        style = ttk.Style()
        style.theme_use('default')
        
        style.configure("Main.TFrame", background="#1E1E1E")
        style.configure("Card.TFrame", background="#2D2D2D", relief="raised")
        style.configure("Modern.TButton",
                       padding=10,
                       background="#007AFF",
                       foreground="white",
                       font=("Helvetica", 10, "bold"))
        style.configure("Status.TLabel",
                       background="#2D2D2D",
                       foreground="#00FF00",
                       font=("Helvetica", 11))
        style.configure("Header.TLabel",
                       background="#1E1E1E",
                       foreground="white",
                       font=("Helvetica", 16, "bold"))

    def create_layout(self):
        # Main container
        main_container = ttk.Frame(self.root, style="Main.TFrame")
        main_container.pack(expand=True, fill=tk.BOTH, padx=20, pady=20)

        # Header
        header = ttk.Frame(main_container, style="Main.TFrame")
        header.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(header,
                 text="Indoor Navigation System",
                 style="Header.TLabel").pack(side=tk.LEFT)

        # Create main content area
        content = ttk.Frame(main_container, style="Main.TFrame")
        content.pack(expand=True, fill=tk.BOTH)

        # Left panel (Controls)
        self.create_control_panel(content)

        # Center panel (Video feed)
        self.create_video_panel(content)

        # Right panel (Detection log)
        self.create_info_panel(content)

    def create_control_panel(self, parent):
        control_panel = ttk.Frame(parent, style="Card.TFrame")
        control_panel.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))

        # Detection controls
        self.create_section(control_panel, "Detection Settings", [
            ("Set Confidence", self.set_confidence),
            ("Set Alert Distance", self.set_alert_distance),
            ("Toggle Announcements", self.toggle_announcements)
        ])

        # Mode selection
        self.create_section(control_panel, "Detection Modes", [
            ("All Objects", lambda: self.set_detection_mode("all")),
            ("People Only", lambda: self.set_detection_mode("person"))
        ])

        # System controls
        self.create_section(control_panel, "System", [
            ("Save Settings", self.save_settings),
            ("Exit", self.exit_application)
        ])

    def create_video_panel(self, parent):
        video_panel = ttk.Frame(parent, style="Card.TFrame")
        video_panel.pack(side=tk.LEFT, expand=True, fill=tk.BOTH)

        # Video canvas
        self.canvas = tk.Canvas(video_panel, 
                              background="#1E1E1E",
                              highlightthickness=0)
        self.canvas.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

        # Status bar
        status_frame = ttk.Frame(video_panel, style="Card.TFrame")
        status_frame.pack(fill=tk.X, padx=10, pady=(0, 10))

        self.status_label = ttk.Label(status_frame,
                                    text="Status: Running",
                                    style="Status.TLabel")
        self.status_label.pack(side=tk.LEFT, padx=10)

        self.fps_label = ttk.Label(status_frame,
                                 text="FPS: 0",
                                 style="Status.TLabel")
        self.fps_label.pack(side=tk.RIGHT, padx=10)

    def create_info_panel(self, parent):
        info_panel = ttk.Frame(parent, style="Card.TFrame")
        info_panel.pack(side=tk.LEFT, fill=tk.Y, padx=(10, 0))

        # Detection log
        ttk.Label(info_panel,
                 text="Detection Log",
                 style="Header.TLabel").pack(pady=10)

        self.log_text = tk.Text(info_panel,
                              width=40,
                              height=20,
                              bg="#2D2D2D",
                              fg="white",
                              font=("Courier", 10))
        self.log_text.pack(padx=10, pady=(0, 10))

        # Statistics display
        self.stats_label = ttk.Label(info_panel,
                                   text="Statistics\n\nObjects Detected: 0\nPeople Count: 0",
                                   style="Status.TLabel")
        self.stats_label.pack(pady=10)

    def create_section(self, parent, title, buttons):
        section = ttk.Frame(parent, style="Card.TFrame")
        section.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(section,
                 text=title,
                 style="Header.TLabel").pack(pady=5)
        
        for text, command in buttons:
            ttk.Button(section,
                      text=text,
                      command=command,
                      style="Modern.TButton").pack(fill=tk.X, padx=5, pady=2)

    def update_frame(self):
        ret, frame = self.cap.read()
        if not ret:
            self.status_label.config(text="Status: Camera Error")
            return

        # Process frame with YOLO
        results = self.model.predict(frame, conf=self.config["confidence"])
        
        # Initialize counters
        object_count = {"total": 0, "person": 0}
        
        # Process detections
        for box in results[0].boxes:
            label = results[0].names[int(box.cls[0])]
            
            # Skip if not in current detection mode
            if self.config["detection_mode"] != "all" and label != self.config["detection_mode"]:
                continue

            # Update counters
            object_count["total"] += 1
            if label == "person":
                object_count["person"] += 1

            # Draw detection box and label
            self.draw_detection(frame, box, label)
            
            # Log detection with details
            self.log_detection(label, box)

        # Update statistics
        self.update_statistics(object_count)
        
        # Display frame
        self.display_frame(frame)

        # Schedule next update
        self.root.after(10, self.update_frame)

    def draw_detection(self, frame, box, label):
        cords = box.xyxy[0].cpu().numpy().astype(int)
        confidence = float(box.conf[0])
        
        # Calculate distance
        object_width = cords[2] - cords[0]
        focal_length = frame.shape[1] / (2 * np.tan(np.radians(35)))
        distance = (focal_length * 0.5) / (object_width + 1e-6)

        # Different colors for different object types
        color = (0, 255, 0) if label == "person" else (0, 165, 255)

        # Draw box
        cv2.rectangle(frame, (cords[0], cords[1]), (cords[2], cords[3]), color, 2)
        
        # Draw label with distance and confidence
        label_text = f"{label} ({distance:.1f}m) {confidence:.2f}"
        cv2.putText(frame, label_text, (cords[0], cords[1] - 10),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

        # Add to speech queue if close enough
        if distance < self.config["alert_distance"]:
            self.queue.put((label, distance, "close", time.time()))

    def start_speech_thread(self):
        def speak_worker():
            engine = pyttsx3.init()
            engine.setProperty("rate", self.config["voice_speed"])
            engine.setProperty("volume", self.config["voice_volume"])
            last_announced = {}

            while True:
                if not self.queue.empty() and self.announcement_enabled[0]:
                    label, distance, position, timestamp = self.queue.get()
                    if time.time() - timestamp > 1:
                        continue
                    
                    object_key = f"{label}_{position}"
                    if (object_key not in last_announced or 
                        time.time() - last_announced[object_key] > self.config["alert_cooldown"]):
                        engine.say(f"Alert: {label} detected {distance:.1f} meters away")
                        engine.runAndWait()
                        last_announced[object_key] = time.time()
                else:
                    time.sleep(0.1)

        t = Thread(target=speak_worker)
        t.daemon = True
        t.start()

    def set_confidence(self):
        value = simpledialog.askfloat("Set Confidence",
                                     "Enter confidence threshold (0-1):",
                                     minvalue=0.0, maxvalue=1.0)
        if value is not None:
            self.config["confidence"] = value

    def set_alert_distance(self):
        value = simpledialog.askfloat("Set Alert Distance",
                                     "Enter alert distance (meters):",
                                     minvalue=0.5, maxvalue=10.0)
        if value is not None:
            self.config["alert_distance"] = value

    def toggle_announcements(self):
        self.announcement_enabled[0] = not self.announcement_enabled[0]
        status = "enabled" if self.announcement_enabled[0] else "disabled"
        self.status_label.config(text=f"Status: Announcements {status}")

    def set_detection_mode(self, mode):
        self.config["detection_mode"] = mode
        self.status_label.config(text=f"Status: {mode.capitalize()} detection mode")

    def save_settings(self):
        with open('detection_settings.json', 'w') as f:
            json.dump(self.config, f)
        messagebox.showinfo("Success", "Settings saved successfully")

    def load_settings(self):
        try:
            with open('detection_settings.json', 'r') as f:
                saved_config = json.load(f)
                self.config.update(saved_config)
        except FileNotFoundError:
            pass

    def log_detection(self, label, box):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        confidence = float(box.conf[0])
        cords = box.xyxy[0].cpu().numpy().astype(int)
        object_width = cords[2] - cords[0]
        focal_length = self.cap.get(3) / (2 * np.tan(np.radians(35)))
        distance = (focal_length * 0.5) / (object_width + 1e-6)
        
        log_entry = f"[{timestamp}] {label} at {distance:.1f}m (Conf: {confidence:.2f})"
        self.detection_log.append(log_entry)
        self.log_text.insert(tk.END, log_entry + "\n")
        self.log_text.see(tk.END)
        
        # Keep log size manageable
        if self.log_text.index('end-1c').split('.')[0] > '1000':
            self.log_text.delete('1.0', '2.0')

    def update_statistics(self, object_count):
        stats_text = (f"Statistics\n\n"
                     f"Objects Detected: {object_count['total']}\n"
                     f"People Count: {object_count['person']}\n"
                     f"Detection Mode: {self.config['detection_mode'].capitalize()}\n"
                     f"Confidence Threshold: {self.config['confidence']:.2f}")
        self.stats_label.config(text=stats_text)

    def display_frame(self, frame):
        try:
            # Calculate FPS
            current_time = time.time()
            if hasattr(self, 'last_frame_time'):
                fps = 1 / (current_time - self.last_frame_time)
                self.fps_label.config(text=f"FPS: {fps:.1f}")
            self.last_frame_time = current_time

            # Get canvas dimensions
            canvas_width = self.canvas.winfo_width()
            canvas_height = self.canvas.winfo_height()
            
            if canvas_width <= 1 or canvas_height <= 1:
                canvas_width = 640
                canvas_height = 480
            
            frame_height, frame_width = frame.shape[:2]
            
            width_scale = canvas_width / frame_width
            height_scale = canvas_height / frame_height
            scale = min(width_scale, height_scale)
            
            if scale > 0 and scale != 1:
                new_width = max(1, int(frame_width * scale))
                new_height = max(1, int(frame_height * scale))
                frame = cv2.resize(frame, (new_width, new_height), interpolation=cv2.INTER_AREA)

            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            img = Image.fromarray(frame_rgb)
            photo = ImageTk.PhotoImage(image=img)
            
            x_center = canvas_width // 2
            y_center = canvas_height // 2
            
            self.canvas.delete("all")
            # Continuing from display_frame method
            self.canvas.delete("all")
            self.canvas.create_image(
                x_center,
                y_center,
                image=photo,
                anchor=tk.CENTER
            )
            self.canvas.image = photo  # Keep a reference to prevent garbage collection
            
        except Exception as e:
            print(f"Error displaying frame: {e}")
            self.status_label.config(text="Status: Display Error")

    def exit_application(self):
        """Clean up resources and exit the application."""
        try:
            # Release camera
            if self.cap is not None:
                self.cap.release()
            
            # Save settings before exit
            self.save_settings()
            
            # Save detection log
            self.save_detection_log()
            
            # Destroy the window
            self.root.destroy()
            
        except Exception as e:
            print(f"Error during cleanup: {e}")
            sys.exit(1)

    def save_detection_log(self):
        """Save the detection log to a file."""
        try:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"detection_log_{timestamp}.txt"
            
            with open(filename, 'w') as f:
                for entry in self.detection_log:
                    f.write(entry + "\n")
                    
            print(f"Detection log saved to {filename}")
            
        except Exception as e:
            print(f"Error saving detection log: {e}")

    def run(self):
        """Start the main application loop."""
        try:
            self.root.mainloop()
        except Exception as e:
            print(f"Error in main loop: {e}")
            self.exit_application()

if __name__ == "__main__":
    try:
        app = ObjectDetectionSystem()
        app.run()
    except Exception as e:
        print(f"Error initializing application: {e}")
        sys.exit(1)